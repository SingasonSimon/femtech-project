import { validationResult } from 'express-validator';
import Product from '../models/Product.js';
import View from '../models/View.js';
import { uploadToCloudinary } from '../config/cloudinary.js';

export const createProduct = async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array()
            });
        }

        const {
            name,
            description,
            shortDescription,
            price,
            originalPrice,
            category,
            brand,
            specifications,
            stock,
            variants,
            tags,
            isFeatured
        } = req.body;

        const createdBy = req.user._id;

        // Handle image uploads
        const images = [];
        if (req.files && req.files.length > 0) {
            try {
                for (let i = 0; i < req.files.length; i++) {
                    const file = req.files[i];
                    const cloudinaryResult = await uploadToCloudinary(file, 'femtech/products');
                    images.push({
                        url: cloudinaryResult.secure_url,
                        alt: `${name} - Image ${i + 1}`,
                        isPrimary: i === 0
                    });
                }
            } catch (uploadError) {
                console.error('Image upload error:', uploadError);
                return res.status(500).json({
                    success: false,
                    message: 'Failed to upload images'
                });
            }
        }

        const product = new Product({
            name,
            description,
            shortDescription,
            price,
            originalPrice,
            category,
            brand,
            specifications: specifications ? JSON.parse(specifications) : {
                dimensions: '',
                weight: '',
                battery: '',
                connectivity: '',
                compatibility: '',
                features: [],
                materials: []
            },
            stock: stock ? JSON.parse(stock) : { quantity: 0, status: 'out_of_stock' },
            variants: variants ? JSON.parse(variants) : [],
            tags: tags ? JSON.parse(tags) : [],
            images,
            isFeatured: isFeatured === 'true' || isFeatured === true,
            isActive: true,
            createdBy
        });

        // SKU will be generated by the model's pre-save hook if needed

        await product.save();
        await product.populate('createdBy', 'displayName email');

        console.log('Product created successfully:', product.name);

        res.status(201).json({
            success: true,
            message: 'Product created successfully',
            data: product
        });
    } catch (error) {
        console.error('Create product error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to create product'
        });
    }
};

export const getProducts = async (req, res) => {
    try {
        const {
            page = 1,
            limit = 12,
            category,
            search,
            minPrice,
            maxPrice,
            sortBy = 'createdAt',
            sortOrder = 'desc',
            isActive = true
        } = req.query;

        let query = {};

        // Handle isActive filter with backward compatibility
        if (isActive === 'true') {
            query.$or = [
                { isActive: true },
                { isActive: { $exists: false } } // Include products without isActive field
            ];
        } else if (isActive === 'false') {
            query.isActive = false;
        }

        // Category filter
        if (category && category !== 'all') {
            query.category = category;
        }

        // Price range filter
        if (minPrice || maxPrice) {
            query.price = {};
            if (minPrice) query.price.$gte = parseFloat(minPrice);
            if (maxPrice) query.price.$lte = parseFloat(maxPrice);
        }

        // Search filter
        if (search) {
            query.$text = { $search: search };
        }

        // Sort options
        const sortOptions = {};
        sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

        const skip = (parseInt(page) - 1) * parseInt(limit);

        const products = await Product.find(query)
            .sort(sortOptions)
            .skip(skip)
            .limit(parseInt(limit))
            .populate('createdBy', 'displayName email');

        const total = await Product.countDocuments(query);

        res.json({
            success: true,
            data: products,
            pagination: {
                current: parseInt(page),
                pages: Math.ceil(total / limit),
                total
            }
        });
    } catch (error) {
        console.error('Get products error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch products'
        });
    }
};

export const getProduct = async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user?._id; // Optional for guest users

        const product = await Product.findById(id)
            .populate('createdBy', 'displayName email');

        if (!product || !product.isActive) {
            return res.status(404).json({
                success: false,
                message: 'Product not found'
            });
        }

        // Track view for logged-in users only (one view per user)
        if (userId) {
            try {
                // Try to create a new view record
                await View.create({
                    userId,
                    targetType: 'Product',
                    targetId: id
                });

                // If successful, increment the view count
                product.viewsCount += 1;
                await product.save();
            } catch (viewError) {
                // If view already exists (duplicate key error), don't increment
                if (viewError.code !== 11000) {
                    console.error('View tracking error:', viewError);
                }
            }
        }

        res.json({
            success: true,
            data: product
        });
    } catch (error) {
        console.error('Get product error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch product'
        });
    }
};

export const updateProduct = async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                success: false,
                message: 'Validation failed',
                errors: errors.array()
            });
        }

        const { id } = req.params;
        const userId = req.user._id;
        const isAdmin = req.user.role === 'admin';

        const product = await Product.findById(id);

        if (!product) {
            return res.status(404).json({
                success: false,
                message: 'Product not found'
            });
        }

        // Check if user can update this product
        if (!isAdmin && product.createdBy.toString() !== userId.toString()) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to update this product'
            });
        }

        const {
            name,
            description,
            shortDescription,
            price,
            originalPrice,
            category,
            brand,
            specifications,
            stock,
            variants,
            tags,
            isFeatured,
            isActive
        } = req.body;

        // Update fields
        if (name) product.name = name;
        if (description) product.description = description;
        if (shortDescription) product.shortDescription = shortDescription;
        if (price !== undefined) product.price = price;
        if (originalPrice !== undefined) product.originalPrice = originalPrice;
        if (category) product.category = category;
        if (brand) product.brand = brand;
        if (specifications) product.specifications = JSON.parse(specifications);
        if (stock) product.stock = JSON.parse(stock);
        if (variants) product.variants = JSON.parse(variants);
        if (tags) product.tags = JSON.parse(tags);
        if (isFeatured !== undefined) product.isFeatured = isFeatured === 'true' || isFeatured === true;
        if (isActive !== undefined && isAdmin) product.isActive = isActive === 'true' || isActive === true;

        // Handle new image uploads
        if (req.files && req.files.length > 0) {
            try {
                for (let i = 0; i < req.files.length; i++) {
                    const file = req.files[i];
                    const cloudinaryResult = await uploadToCloudinary(file, 'femtech/products');
                    product.images.push({
                        url: cloudinaryResult.secure_url,
                        alt: `${product.name} - Image ${i + 1}`,
                        isPrimary: product.images.length === 0 && i === 0
                    });
                }
            } catch (uploadError) {
                console.error('Image upload error:', uploadError);
                return res.status(500).json({
                    success: false,
                    message: 'Failed to upload images'
                });
            }
        }

        await product.save();
        await product.populate('createdBy', 'displayName email');

        res.json({
            success: true,
            message: 'Product updated successfully',
            data: product
        });
    } catch (error) {
        console.error('Update product error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to update product'
        });
    }
};

export const deleteProduct = async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user._id;
        const isAdmin = req.user.role === 'admin';

        const product = await Product.findById(id);

        if (!product) {
            return res.status(404).json({
                success: false,
                message: 'Product not found'
            });
        }

        // Check if user can delete this product
        if (!isAdmin && product.createdBy.toString() !== userId.toString()) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to delete this product'
            });
        }

        // Soft delete by setting isActive to false
        product.isActive = false;
        await product.save();

        res.json({
            success: true,
            message: 'Product deleted successfully'
        });
    } catch (error) {
        console.error('Delete product error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to delete product'
        });
    }
};

export const getFeaturedProducts = async (req, res) => {
    try {
        const { limit = 6 } = req.query;

        const products = await Product.find({
            isActive: true,
            isFeatured: true
        })
            .sort({ createdAt: -1 })
            .limit(parseInt(limit))
            .populate('createdBy', 'displayName email');

        res.json({
            success: true,
            data: products
        });
    } catch (error) {
        console.error('Get featured products error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch featured products'
        });
    }
};

export const getProductCategories = async (req, res) => {
    try {
        const categories = await Product.distinct('category', { isActive: true });

        const categoryData = await Promise.all(
            categories.map(async (category) => {
                const count = await Product.countDocuments({ category, isActive: true });
                return { category, count };
            })
        );

        res.json({
            success: true,
            data: categoryData
        });
    } catch (error) {
        console.error('Get product categories error:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch product categories'
        });
    }
};
